船吸和船挤在当前tick运算的顺序：
	1.	水下踢人(船弹)
	2.	其他各种逻辑：状态、受伤、移动、气泡柱等
	3.	拉客上船(船吸)
	4.	拉不了的客人就挤走(船挤)

船吸和船挤条件：
	如果：“船长”不是玩家
	那么：
		遍历：“船碰撞箱水平四向膨胀0.2m，上下缩小0.01m”能接触的“可以被船推动的(pushableBy)”的实体
			如果：
				此实体的乘客不包含这个船
				and 船未满员
				and 此实体不是乘客
				(以上为多为废话，下面几个比较常用)
				and 实体宽度 < 船宽度(1.375m = 1m 6px)
				and 实体是livingEntity(玩家、盔甲架、生物Mob)
				and 实体不是EntityTypeTags.CANNOT_BE_PUSHED_ONTO_BOATS
					玩家、嘎吱
					水生环境类：各种桶装生物
					水生动物：海豚、鱿鱼、发光鱿鱼、鹦鹉螺、僵尸鹦鹉螺
			
			那么：实体尝试执行上船
				注意：船额外要求船的视线不在水里，否则执行过程中就会失败，最后的表现就是既不船吸，又不船挤
				船的视线在水里的判据为：pos.getY() + fluidState.getHeight(pos) > this.position.y + this.eyeHeight = this.position.y + 0.5625
				简而言之，视线不再水里要求眼睛高度>=水位高度
				当船在水下顶着某个方块底部时，刚好处于船的视线不在水里的状态	
			否则：尝试推挤实体(需要满足相对高度要求)：
				对方不是船：自己底部 >= 对方底部  # 常用船挤条件
				对方是船：自己顶部 > 对方底部

船吸和船挤情况：
	无法船吸，会互相挤压：
		船空载 and 生物不满足上船条件
	无法船吸，船挤生物，生物无法挤船：
		船载客 and 生物不满足上船条件
	无法船吸，船和生物互不挤压：
		生物满足上传条件 and 船因为视线在水里导致生物尝试上船失败

降低船的卡顿：
	由于船获取状态要遍历很多方块，起遍历的顺序为水下->水中->落地->空中
	如果让船在第一步就因为判断为在水中，就把后续的各种检测停了，那么可以剩下很多计算量
	如果能在被遍历的前几个方块就是流动水那就更好了，
	因为遇到流动水就不再继续检查，返回优先级最高的状态UNDER_FLOWING_WATER
	(遍历的顺序为字典顺序(xyz,-到+))
	
	理想中船卡顿最低的状态：船在水下，最好船顶的西北角为流动的水，浮空(被气泡柱等)，船底不顶着方块底部(否则遍历范围加倍)

船的每tick运算：
	# === 1. 状态更新 ===
	获取船的状态 getStatus()：
		水下（UNDER_FLOWING_WATER, UNDER_WATER）：
			AABB = (船顶部 ~ 船顶部+0.001)的碰撞箱区域
			遍历AABB能碰到的方块，判断是否存在：
				如果：此方块为水 and 船碰撞箱maxY + 0.001 < 某个水的水位
				那么：
					underWater = true
					如果：此方块为水流水，
					那么：返回 UNDER_FLOWING_WATER，并 waterLevel = 碰撞箱maxY(船顶)
			
			如果：underWater = true
			那么：返回 UNDER_WATER，并 waterLevel = 碰撞箱maxY(船顶)
			否则：返回null

		水中（IN_WATER）：
			AABB = (船底部 ~ 船底部+0.001)的碰撞箱区域
			遍历AABB能碰到的方块，判断是否存在：
				如果：此方块为水 and 船碰撞箱minY < 此水的水位高度
				那么：inWater = true
			如果：inWater = true
			那么：返回IN_WATER，并且 this.waterLevel = max(所有水的水位高度)
			否则：this.waterLevel = -Double.MAX_VALUE

		落地和空中（ON_LAND和IN_AIR）：
			获取地面摩擦力 f = getGroundFriction()
			如果 f>0 ：
				this.landFriction = f;
				Status设置为在陆地上（ON_LAND）
			否则(f<=0)：
				Status设置为在空中（ON_LAND）
	

    # === 2. 水下踢人 ===
    if UNDER_WATER or UNDER_FLOWING_WATER:
        outOfControlTicks += 1
        if 失控时间 >= 60:
            弹出所有乘客()
    else:
        重置失控计时器()
    
    # === 3. 伤害处理 ===
    if 受伤时间 > 0: 受伤时间--
    if 伤害值 > 0: 伤害值--
    
    # === 4. 父类逻辑 ===
    super.tick()  # 执行VehicleEntity的tick
    
    # === 5. 客户端插值计算 ===
    # === 6. 物理模拟=== # 船被玩家控制的时候，表现的类似于客户端运算
    if 实体由当前实例控制:
        if 没有玩家控制: 停止划桨动画()
        执行漂浮逻辑()  # 根据状态调整浮力/重力
        if 客户端:
            处理玩家输入()  # 转向/加速
            发送划桨数据包到服务端()
        应用当前速度移动实体()
    else:  # 远程实体
        速度归零()
    
    # === 7. 环境效果 ===
    # === 8. 气泡柱处理 ===
	if 位于气泡柱上:
		if 气泡时间 > 0:
			减少气泡时间()
			if 气泡结束:
				根据方向弹射实体()  # 上抛或下坠
    
    # === 9. 划桨处理 ===
    # === 10. 实体交互 ===
    获取范围内实体：碰撞箱.inflate(0.2, -0.01, 0.2), EntitySelector.pushableBy(this)
	如果：获取到的实体列表非空 and “船长”不是玩家
	那么：
		for 获取到的实体列表：
		如果此实体没有乘客，那么：
			如果:
				船的乘客数量 < 此船的最大乘客数量
				and 此实体不是乘客
				and 实体不是玩家
				and 实体宽度小于船
				and 实体是livingEntity(玩家、盔甲架、生物Mob)
				and 实体不是WaterAnimal(各种桶装类)
				and 实体不是嘎吱
			那么：拉客上船
		否则：push(此实体)，要满足的条件(高度关系)为：
				对方不是船：自己底部 >= 对方底部
				对方是船：自己顶部 > 对方底部
		
	