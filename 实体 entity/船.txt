getStatus()：
	在水下（UNDER_FLOWING_WATER, UNDER_WATER）：
		遍历所有船能碰到的方块，判断是否存在：
			船碰撞箱maxY + 0.001 < 某个水的水位
		如果满足，设置此状态，并把船的水位(this.waterLevel)设置为碰撞箱maxY
		(两个状态流水的优先级大于水源)
		
	部分浸水状态（IN_WATER）：
		遍历所有船能碰到的方块，判断是否存在：
			船碰撞箱minY < 某个水的水位高度
		另外船的水位(this.waterLevel) = max(所有水的水位高度)
		若未接触到水，船的水位(this.waterLevel) = -Double.MAX_VALUE

	在陆地上和在空中状态（ON_LAND和IN_AIR）：
		获取地面摩擦力 f = getGroundFriction()
		如果 f>0 ：
			this.landFriction = f;
			Status设置为在陆地上（ON_LAND）
		否则(f<=0)：
			Status设置为在空中（ON_LAND）

船tick():
    # === 1. 状态更新 ===
    oldStatus = status
    status = 计算当前状态()
		IN_WATER        // 漂浮水面
		UNDER_WATER     // 完全浸没（水源方块）
		UNDER_FLOWING_WATER  // 浸没（流动水）
		ON_LAND         // 接触陆地
		IN_AIR          // 空中坠落
    
    # === 2. 失控检测 ===
    if UNDER_WATER or UNDER_FLOWING_WATER:
        outOfControlTicks += 1
        if 失控时间 >= 60:
            弹出所有乘客()
    else:
        重置失控计时器()
    
    # === 3. 伤害处理 ===
    if 受伤时间 > 0: 受伤时间--
    if 伤害值 > 0: 伤害值--
    
    # === 4. 父类逻辑 ===
    super.tick()  # 执行VehicleEntity的tick
    
    # === 5. 插值计算 ===
    插值处理器.更新()  # 客户端平滑实体位置
    
    # === 6. 物理模拟（仅本地实例）===
    if 实体由当前实例控制:
        if 没有玩家控制: 停止划桨动画()
        执行漂浮逻辑()  # 根据状态调整浮力/重力
        if 客户端:
            处理玩家输入()  # 转向/加速
            发送划桨数据包到服务端()
        应用当前速度移动实体()
    else:  # 远程实体
        速度归零()
    
    # === 7. 环境效果 ===
    应用方块效果()  # 2次调用（未在代码中显示具体实现）
    
    # === 8. 气泡柱处理 ===
    if 客户端:
        更新气泡动画参数()
    else:
        if 位于气泡柱上:
            if 气泡时间 > 0:
                减少气泡时间()
                if 气泡结束:
                    根据方向弹射实体()  # 上抛或下坠
    
    # === 9. 划桨处理 ===
    for 左右桨索引 in [0,1]:
        if 桨在划动:
            更新桨叶角度()
            if 到达播放音效角度 and 非静音:
                播放划水音效()  # 根据环境选择水/陆地音效
        else:
            重置桨叶角度()
    
    # === 10. 实体交互 ===
    获取周围碰撞实体()
    for 实体 in 碰撞列表:
        if 可被推挤:
            if 服务端 and 船有空位 and 实体可上船:
                实体上船()
            else:
                推挤实体()
	
	


获取船的状态:
    private Boat.Status getStatus() {
        Boat.Status status = this.isUnderwater();
        if (status != null) {
            this.waterLevel = this.getBoundingBox().maxY;
            return status;
        } else if (this.checkInWater()) {
            return Boat.Status.IN_WATER;
        } else {
            float f = this.getGroundFriction();
            if (f > 0.0F) {
                this.landFriction = f;
                return Boat.Status.ON_LAND;
            } else {
                return Boat.Status.IN_AIR;
            }
        }
    }

在水下(isUnderwater)
船碰撞箱向上扩展1mm，把这个范围内碰到的的所有方块全部检查一遍：流体的水位高度是否大于船碰撞箱顶部+0.001m，如果大于那就是在水里。
这个流体是否为水源决定着船到底是(UNDER_WATER)还是(UNDER_FLOWING_WATE)，仅仅是在水源里(UNDER_WATER)并不会停止继续遍历，但是如果遇到一个能浸没船的非水源(流动水)会立刻返回(UNDER_FLOWING_WATE)并停止继续查找。


在水中(checkInWater)
船碰撞箱向上扩展1mm，把这个范围内碰到的的所有方块全部检查一遍：如果是水，则记录高度，最后遍历完之后this.waterLevel为最高的水位(相对于船底部的高度)


如果船不在水下，那么outOfControlTicks=0，如果在水下，outOfControlTicks++
然后如果outOfControlTicks>=60，弹射乘客